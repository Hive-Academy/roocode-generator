---
title: Implementation Plan
type: template
category: implementation
status: active
taskId: TSK-013
---

# Implementation Plan: TSK-013/ImplementLlmAstAnalysis

## 1. Overview

This plan outlines the steps to implement **TSK-013: Implement LLM Analysis of AST Data**. The goal is to enhance the `ProjectAnalyzer` by introducing a new service, `AstAnalysisService`, which uses an LLM to analyze the generic Abstract Syntax Tree (`astData`) generated in TSK-008. This analysis will extract structured code insights (functions, classes, imports) and store them in the `ProjectContext`.

The implementation will follow the recommendations from the research report included in the task description, specifically starting with "Approach 1: Direct LLM Call per File".

See [[task-tracking/TSK-013-ImplementLlmAstAnalysis/task-description.md]] for detailed requirements and the full research report.

## 2. Implementation Strategy

### 2.1. Approach

1.  **New Service (`AstAnalysisService`):** Create a dedicated service responsible for:
    - Accepting `astData` (`GenericAstNode`).
    - Constructing a detailed prompt including task description, `astData` structure explanation, the target `CodeInsights` JSON schema (defined via TypeScript interface), and few-shot examples.
    - Calling the `LLMAgent` to get LLM completion.
    - Validating the LLM response is valid JSON and conforms to the `CodeInsights` schema using the `zod` library.
    - Returning the validated `CodeInsights` or an error using the `Result` pattern.
2.  **Interface Definitions:** Define new interfaces (`IAstAnalysisService`, `CodeInsights`, `FunctionInfo`, `ClassInfo`, `ImportInfo`) in a dedicated file (`ast-analysis.interfaces.ts`).
3.  **`ProjectContext` Update:** Add a `codeInsights?: { [filePath: string]: CodeInsights }` field to the `ProjectContext` interface (`types.ts`).
4.  **`ProjectAnalyzer` Integration:**
    - Inject `IAstAnalysisService`.
    - After generating `astData` for each file, call `astAnalysisService.analyzeAst(astData)` concurrently using `Promise.all`.
    - Handle the `Result`: If `ok`, merge insights into `projectContext.codeInsights`. If `err`, log a warning using `ILogger` and continue analysis for other files.
5.  **Dependency Management:** Add `zod` as a project dependency.
6.  **DI Registration:** Register `AstAnalysisService` in the appropriate DI module (e.g., `core-module.ts` or a new `analysis-module.ts`).

### 2.2. Key Components

- **Create:**
  - `src/core/analysis/ast-analysis.service.ts`
  - `src/core/analysis/ast-analysis.interfaces.ts`
  - Unit tests for `AstAnalysisService` (e.g., `tests/core/analysis/ast-analysis.service.test.ts`)
- **Modify:**
  - `src/core/analysis/project-analyzer.ts`
  - `src/core/analysis/types.ts`
  - `src/core/di/modules/core-module.ts` (or new analysis module)
  - `package.json` / `package-lock.json` (to add `zod`)
- **Use:**
  - `src/core/llm/llm-agent.ts` (`LLMAgent`)
  - `src/core/result/result.ts` (`Result`)
  - `src/core/services/logger-service.ts` (`ILogger`)
  - `zod` library

### 2.3. Dependencies

- Internal: `LLMAgent`, `ILogger`, `Result`, `GenericAstNode`, `ProjectContext`.
- External: `zod` (new).

### 2.4. Risk Areas

- **Prompt Engineering:** Crafting an effective prompt that consistently extracts the desired structure from varied `astData` is critical and may require iteration.
- **LLM Reliability/Variability:** LLM responses might be inconsistent, fail validation, or contain hallucinations. Robust validation (`zod`) and error handling (`Result`, logging in `ProjectAnalyzer`) are essential.
- **`astData` Size:** While starting with direct calls, large files might generate `astData` exceeding LLM context windows. Token counting and monitoring will be needed, potentially requiring future implementation of chunking (Approach 2).
- **Input `astData` Quality:** Relies on the `astData` generated by `TreeSitterParserService` (TSK-008). Existing deferred test debt for TSK-008 means input quality might vary.
- **Performance:** Concurrent LLM calls help, but analyzing many files can still be time-consuming. Batching (if supported) could be a future optimization.

## 3. Acceptance Criteria Mapping

- **AC1 (Service Created):** Covered by Subtask 1 & 2.
- **AC2 (Context Updated):** Covered by Subtask 1.
- **AC3 (Integration):** Covered by Subtask 3.
- **AC4 (Concurrency):** Covered by Subtask 3.
- **AC5 (LLM Interaction):** Covered by Subtask 2.
- **AC6 (Prompt Definition):** Covered by Subtask 2.
- **AC7 (Structured Output):** Covered by Subtask 1 (interface definition) & Subtask 2 (prompting/validation).
- **AC8 (Validation):** Covered by Subtask 2 (implementing `zod`).
- **AC9 (Error Handling):** Covered by Subtask 2 (`Result` return) & Subtask 3 (handling `Result`).
- **AC10 (Basic Functionality):** Verified via testing (Subtask 4/5).
- **AC11 (No New Config):** Ensured by design (uses existing LLM config).
- **AC12 (Documentation):** Covered by all implementation subtasks (TSDoc).

## 4. Implementation Subtasks

### Subtask 1: Define Interfaces & Update Context

**Status**: Completed

**Description**: Define the necessary interfaces for the AST analysis feature and update the `ProjectContext` to accommodate the results. Add `zod` dependency.

**Files to Modify**:

- `src/core/analysis/ast-analysis.interfaces.ts` (Create): Define `IAstAnalysisService`, `CodeInsights`, `FunctionInfo`, `ClassInfo`, `ImportInfo`.
- `src/core/analysis/types.ts` (Modify): Add `codeInsights?: { [filePath: string]: CodeInsights };` to `ProjectContext`.
- `package.json`, `package-lock.json` (Modify): Add `zod` dependency.

**Implementation Details**:

```typescript
// src/core/analysis/ast-analysis.interfaces.ts
import { Result } from '../result/result';
import { GenericAstNode } from './types';

export interface FunctionInfo {
  name: string;
  parameters: string[];
  // Optional: startLine?: number; endLine?: number;
}

export interface ClassInfo {
  name: string;
  // Optional: methods?: FunctionInfo[]; properties?: string[]; startLine?: number; endLine?: number;
}

export interface ImportInfo {
  source: string; // The path/module being imported (e.g., 'react', './utils')
  // Optional: importedSymbols?: string[]; isDefault?: boolean;
}

export interface CodeInsights {
  functions: FunctionInfo[];
  classes: ClassInfo[];
  imports: ImportInfo[];
  // Potentially add other insights later: variables, exports, etc.
}

export interface IAstAnalysisService {
  analyzeAst(astData: GenericAstNode, filePath: string): Promise<Result<CodeInsights, Error>>;
}

// Add TSDoc comments to all interfaces and members.
```

**Testing Requirements**:

- N/A for this subtask (interfaces only). Dependency installation verified by `npm install`.

**Related Acceptance Criteria**:

- AC2: `ProjectContext` updated.
- AC7: Structure for output defined.

**Estimated effort**: 15 minutes

**Required Delegation Components**:

- Implementation components for Junior Coder:
  - Define `FunctionInfo`, `ClassInfo`, `ImportInfo`, `CodeInsights` interfaces based on the structure above.
- Testing components for Junior Tester: N/A

**Delegation Success Criteria**:

- Junior Coder components must: Interfaces correctly defined with TSDoc comments in the specified file. `ProjectContext` updated correctly with TSDoc.

**Completion Notes**:

- `zod` dependency installed successfully via `npm install zod --save-exact`.
- Interface creation (`ast-analysis.interfaces.ts`) and `ProjectContext` update (`types.ts`) were delegated to Junior Coder.
- Junior Coder confirmed completion and adherence to specifications, including TSDoc comments.

**Acceptance Criteria Verification**:

- AC2: `ProjectContext` updated.
  - ✅ Satisfied by: Junior Coder added `codeInsights?: { [filePath: string]: CodeInsights };` with TSDoc to `ProjectContext` in `src/core/analysis/types.ts`.
  - Evidence: Junior Coder completion report confirmed the change.
- AC7: Structure for output defined.
  - ✅ Satisfied by: Junior Coder defined `CodeInsights`, `FunctionInfo`, `ClassInfo`, `ImportInfo` interfaces with TSDoc in `src/core/analysis/ast-analysis.interfaces.ts`.
  - Evidence: Junior Coder completion report confirmed the creation and content of the file.
- AC12: TSDoc comments added.
  - ✅ Satisfied by: Junior Coder included TSDoc comments for all new interfaces, members, and the updated `ProjectContext` field as per requirements.
  - Evidence: Junior Coder completion report confirmed the presence of TSDoc.

---

### Subtask 2: Implement `AstAnalysisService` Core Logic

**Status**: Completed

**Description**: Implement the core logic of `AstAnalysisService`, including prompt construction, LLM interaction via `LLMAgent`, and response validation using `zod`.

**Files to Modify**:

- `src/core/analysis/ast-analysis.service.ts` (Create): Implement the `analyzeAst` method.

**Implementation Details**:

1.  **Constructor:** Inject `LLMAgent` and `ILogger`.
2.  **`analyzeAst` Method:**
    - Receive `astData: GenericAstNode` and `filePath: string`.
    - **Prompt Construction:**
      - Create a detailed system prompt string. Include:
        - Clear task instruction (analyze `astData` JSON for functions, classes, imports).
        - Description of the `GenericAstNode` structure (type, text, children, etc.).
        - The target `CodeInsights` TypeScript interface definition (copied from `ast-analysis.interfaces.ts`).
        - Instruction to return ONLY valid JSON matching the interface.
        - At least one few-shot example: Show a simplified `astData` JSON snippet and the corresponding `CodeInsights` JSON output.
    - **LLM Call:**
      - Use `JSON.stringify(astData)` as the user prompt content.
      - Call `this.llmAgent.getCompletion(systemPrompt, astDataJsonString)`.
      - Handle potential errors from `getCompletion` (return `Result.err`).
    - **Validation:**
      - Define a `zod` schema corresponding exactly to the `CodeInsights` interface.
      - Try parsing the LLM response string using `JSON.parse()`. Catch parsing errors and return `Result.err`.
      - Use the `zodSchema.safeParse(parsedJson)` method to validate the parsed object against the schema.
      - If `safeParse` fails, log the validation errors (`result.error.issues`) and return `Result.err` with a descriptive error message.
    - **Return:** If validation succeeds, return `Result.ok(validatedData)`.

````typescript
// src/core/analysis/ast-analysis.service.ts (Conceptual)
import { Injectable, Inject } from '../di/decorators';
import {
  IAstAnalysisService,
  CodeInsights,
  FunctionInfo,
  ClassInfo,
  ImportInfo,
} from './ast-analysis.interfaces';
import { GenericAstNode } from './types';
import { Result } from '../result/result';
import { ILLMAgent } from '../llm/interfaces';
import { ILogger } from '../services/logger-service';
import { z, ZodType } from 'zod';
import { RooCodeError } from '../errors'; // Or a more specific error type

// Define Zod schema matching CodeInsights
const functionInfoSchema = z.object({
  name: z.string(),
  parameters: z.array(z.string()),
});

const classInfoSchema = z.object({
  name: z.string(),
});

const importInfoSchema = z.object({
  source: z.string(),
});

const codeInsightsSchema: ZodType<CodeInsights> = z.object({
  functions: z.array(functionInfoSchema),
  classes: z.array(classInfoSchema),
  imports: z.array(importInfoSchema),
});

@Injectable()
export class AstAnalysisService implements IAstAnalysisService {
  constructor(
    @Inject('LLMAgent') private readonly llmAgent: ILLMAgent,
    @Inject('ILogger') private readonly logger: ILogger
  ) {}

  async analyzeAst(
    astData: GenericAstNode,
    filePath: string
  ): Promise<Result<CodeInsights, Error>> {
    this.logger.debug(`Analyzing AST for file: ${filePath}`);

    const systemPrompt = this.buildPrompt(); // Define this method
    const astDataJsonString = JSON.stringify(astData); // Consider potential size issues later

    // Optional: Add token counting check here if needed later
    // const tokenCount = await this.llmAgent.countTokens(systemPrompt + astDataJsonString);
    // if (tokenCount > MAX_TOKENS) return Result.err(...)

    const completionResult = await this.llmAgent.getCompletion(systemPrompt, astDataJsonString);

    if (completionResult.isErr()) {
      this.logger.error(`LLM call failed for ${filePath}: ${completionResult.error.message}`);
      return Result.err(completionResult.error);
    }

    const rawResponse = completionResult.value;
    let parsedJson: unknown;

    try {
      // Clean potential markdown fences
      const cleanedResponse = rawResponse.replace(/```json\n?([\s\S]*?)\n?```/g, '$1').trim();
      parsedJson = JSON.parse(cleanedResponse);
    } catch (parseError) {
      this.logger.warn(
        `Failed to parse LLM JSON response for ${filePath}: ${parseError instanceof Error ? parseError.message : String(parseError)}`
      );
      this.logger.debug(`Raw response for ${filePath}:\n${rawResponse}`);
      return Result.err(
        new RooCodeError(`Invalid JSON response from LLM for ${filePath}`, { cause: parseError })
      );
    }

    const validationResult = codeInsightsSchema.safeParse(parsedJson);

    if (!validationResult.success) {
      this.logger.warn(
        `LLM response validation failed for ${filePath}: ${validationResult.error.message}`
      );
      this.logger.debug(`Validation issues: ${JSON.stringify(validationResult.error.issues)}`);
      this.logger.debug(`Parsed JSON for ${filePath}:\n${JSON.stringify(parsedJson, null, 2)}`);
      return Result.err(
        new RooCodeError(`LLM response failed schema validation for ${filePath}`, {
          cause: validationResult.error,
        })
      );
    }

    this.logger.debug(`Successfully analyzed and validated AST insights for ${filePath}`);
    return Result.ok(validationResult.data);
  }

  private buildPrompt(): string {
    // Construct the detailed prompt with instructions, schema, and few-shot example here.
    // Reference task description Section 2, Prompt Engineering.
    const prompt = `
### Instruction ###
Analyze the provided JSON AST ('astData') representing a source code file. Extract all top-level function definitions, class definitions, and import statements.
The 'astData' has nodes with a 'type' property (e.g., 'function_definition', 'class_definition', 'import_statement', 'identifier', 'formal_parameters', 'string_literal') and a 'children' array.
- Function names are typically in an 'identifier' node within 'function_definition'.
- Parameters are within 'formal_parameters' -> 'parameter_declaration' -> 'identifier'.
- Class names are typically in an 'identifier' node within 'class_definition'.
- Import sources are typically in a 'string_literal' or similar node within 'import_statement'.

Return the results ONLY as a valid JSON object matching the following TypeScript interface. Do NOT include any other text, explanations, or markdown formatting.

\`\`\`typescript
interface FunctionInfo {
  name: string;
  parameters: string[];
}

interface ClassInfo {
  name: string;
}

interface ImportInfo {
  source: string;
}

interface CodeInsights {
  functions: FunctionInfo[];
  classes: ClassInfo[];
  imports: ImportInfo[];
}
\`\`\`

### Example Input ('astData' Snippet) ###

\`\`\`json
{
  "type": "program",
  "children": [
    {
      "type": "import_statement",
      "children": [
        { "type": "import_clause", "children": [...] },
        { "type": "string_literal", "text": "'react'" }
      ]
    },
    {
      "type": "function_definition",
      "children": [
        { "type": "identifier", "text": "calculateTotal" },
        {
          "type": "formal_parameters",
          "children": [
            { "type": "parameter_declaration", "children": [{ "type": "identifier", "text": "price" }] },
            { "type": "parameter_declaration", "children": [{ "type": "identifier", "text": "quantity" }] }
          ]
        },
        { "type": "block", "children": [] }
      ]
    },
    {
      "type": "class_definition",
      "children": [
        { "type": "identifier", "text": "Product" },
        { "type": "class_body", "children": [] }
      ]
    }
  ]
}
\`\`\`

### Example Output (JSON only) ###

\`\`\`json
{
  "functions": [{ "name": "calculateTotal", "parameters": ["price", "quantity"] }],
  "classes": [{ "name": "Product" }],
  "imports": [{ "source": "react" }]
}
\`\`\`

### Input 'astData' ###

\`\`\`json
{{AST_DATA_JSON}}
\`\`\`

### Output (JSON only) ###

\`\`\`json

`;
    // Replace placeholder in the actual call
    return prompt.replace('{{AST_DATA_JSON}}', ''); // Base prompt structure
  }
}
````

**Testing Requirements**:

- Unit tests for `AstAnalysisService`:
  - Mock `LLMAgent.getCompletion`.
  - Test successful path: valid JSON response matching schema -> `Result.ok(CodeInsights)`.
  - Test failure paths:
    - `LLMAgent` returns error -> `Result.err`.
    - LLM returns invalid JSON -> `Result.err`.
    - LLM returns valid JSON but fails `zod` schema validation -> `Result.err`.
  - Verify prompt construction (partially, e.g., check for key sections).
  - Verify logger calls on success/failure.

**Related Acceptance Criteria**:

- AC1: Service implemented.
- AC5: Uses `LLMAgent`.
- AC6: Prompt defined.
- AC7: Attempts extraction.
- AC8: Validation implemented.
- AC9: Returns `Result`.
- AC12: TSDoc added.

**Estimated effort**: 30-45 minutes

**Required Delegation Components**:

- Implementation components for Junior Coder:
  - Implement the `zod` schema (`codeInsightsSchema` and sub-schemas).
  - Implement the `buildPrompt` method based on the provided structure and task description examples.
- Testing components for Junior Tester:
  - Implement unit tests covering success and failure paths described above.

**Delegation Success Criteria**:

- Junior Coder components: ✅ Completed. Zod schemas (`codeInsightsSchema` etc.) correctly implemented in `ast-analysis.service.ts` and reviewed. `buildPrompt` method correctly implemented in `ast-analysis.service.ts` and reviewed.
- Junior Tester components: ✅ Completed (after 1 redelegation). Unit tests in `ast-analysis.service.test.ts` cover all specified scenarios, use mocks correctly, and verify outcomes/logging. Reviewed and approved.

**Completion Notes**:

- Created `src/core/analysis/ast-analysis.service.ts`.
- Implemented `AstAnalysisService` class conforming to `IAstAnalysisService`.
- Injected `ILLMAgent` and `ILogger` via constructor.
- Implemented `analyzeAst` method:
  - Calls `buildPrompt` (delegated to Junior Coder).
  - Stringifies `astData` and includes it in the system prompt.
  - Calls `llmAgent.getCompletion` with the combined prompt and an empty user prompt.
  - Handles `Result` from LLM call (logs error on failure).
  - Cleans potential markdown fences from the response.
  - Parses response string as JSON (logs warning on failure, returns `RooCodeError`).
  - Validates parsed JSON using `codeInsightsSchema` (delegated to Junior Coder).
  - Handles validation failure (logs warning/issues, returns `RooCodeError`).
  - Returns `Result.ok(validatedData)` on success.
  - Added TSDoc comments for the class and public method.
- Delegated Zod schema implementation (`codeInsightsSchema` etc.) to Junior Coder - Successful.
- Delegated `buildPrompt` method implementation to Junior Coder - Successful.
- Delegated unit test implementation (`tests/core/analysis/ast-analysis.service.test.ts`) to Junior Tester - Successful after 1 redelegation due to initial non-completion. Tests reviewed and verified.
- Corrected TypeScript errors related to `RooCodeError` constructor and logger calls during implementation.

**Acceptance Criteria Verification**:

- AC1: Service implemented.
  - ✅ Satisfied by: `AstAnalysisService` class created in `src/core/analysis/ast-analysis.service.ts`, implementing `IAstAnalysisService`.
  - Evidence: Code file `src/core/analysis/ast-analysis.service.ts`.
- AC5: Uses `LLMAgent`.
  - ✅ Satisfied by: `ILLMAgent` injected in constructor and `llmAgent.getCompletion` called within `analyzeAst`.
  - Evidence: Code inspection; Verified by unit test `should return Ok with CodeInsights...`.
- AC6: Prompt defined.
  - ✅ Satisfied by: `buildPrompt` method implemented (delegated to Junior Coder) and called by `analyzeAst`. System prompt includes instructions, schema, example, and input AST.
  - Evidence: Code inspection; Verified by unit test `should build a prompt containing key elements`.
- AC7: Attempts extraction.
  - ✅ Satisfied by: The prompt explicitly instructs the LLM to extract functions, classes, and imports based on the AST structure.
  - Evidence: `buildPrompt` method content.
- AC8: Validation implemented.
  - ✅ Satisfied by: `codeInsightsSchema` (delegated to Junior Coder) defined using Zod and `safeParse` used in `analyzeAst` to validate the parsed LLM response.
  - Evidence: Code inspection; Verified by unit tests `should return Ok...` and `should return Err... when LLM response fails schema validation`.
- AC9: Returns `Result`.
  - ✅ Satisfied by: `analyzeAst` method returns `Promise<Result<CodeInsights, Error>>`. `Result.ok` returned on success, `Result.err` with `RooCodeError` returned on failures (LLM, parse, validation, unexpected).
  - Evidence: Method signature and return statements; Verified by all unit tests checking `result.isOk()` or `result.isErr()`.
- AC12: TSDoc added.
  - ✅ Satisfied by: TSDoc comments added to `AstAnalysisService` class and `analyzeAst` method. Delegated components (`buildPrompt`, Zod schemas) also included TSDoc as verified during review.
  - Evidence: Code inspection of `src/core/analysis/ast-analysis.service.ts`.

---

### Subtask 3: Integrate `AstAnalysisService` into `ProjectAnalyzer`

**Status**: Not Started

**Description**: Modify `ProjectAnalyzer` to use the new `AstAnalysisService` to analyze `astData` for each file concurrently and merge the results into `ProjectContext`.

**Files to Modify**:

- `src/core/analysis/project-analyzer.ts`

**Implementation Details**:

1.  **Constructor:** Inject `IAstAnalysisService` using the token `'IAstAnalysisService'`.
2.  **Modify `analyzeProject` Method:**
    - Locate the loop or map operation where `astData` is generated for each file (currently inside the `for (const filePath of allFiles.value)` loop).
    - Instead of directly assigning `astData` inside the loop, collect pairs of `[filePath, astData]` or create an array of promises.
    - **Concurrency:** After the loop (or after collecting all `astData`), use `Promise.all` to call `this.astAnalysisService.analyzeAst(astData, relativePath)` for each file's `astData`.
    - **Result Handling:** Iterate through the results from `Promise.allSettled` (safer to handle individual promise rejections) or `Promise.all` (if okay with all-or-nothing for the batch, though requirements say continue on single failure).
      - For each successful analysis (`Result.ok(insights)`), add the insights to the `finalContext.codeInsights` map: `finalContext.codeInsights[relativePath] = insights;`. Initialize `finalContext.codeInsights = {};` if it doesn't exist.
      - For each failed analysis (`Result.err(error)`), log a warning using `this.logger.warn("Failed to get code insights for file [relativePath]:", error.message);`. Do **not** stop the overall project analysis.
    - Ensure the final `ProjectContext` returned includes the populated `codeInsights` field (or an empty object if no analysis succeeded).

```typescript
// src/core/analysis/project-analyzer.ts (Conceptual Changes)

// ... imports ...
import { IAstAnalysisService, CodeInsights } from './ast-analysis.interfaces'; // Import new interfaces
import { RooCodeError } from '../errors'; // Import base error

// ... constructor ...
constructor(
  // ... other injections ...
  @Inject('ITreeSitterParserService') private readonly treeSitterParserService: ITreeSitterParserService,
  @Inject('IAstAnalysisService') private readonly astAnalysisService: IAstAnalysisService // Inject new service
) { // ... }

async analyzeProject(paths: string[]): Promise<Result<ProjectContext, Error>> {
  // ... existing setup ...
  try {
    // ... file collection, prioritization, content collection ...

    // --- Tree-sitter Parsing Step ---
    this.progress.update('Parsing supported files for structure...');
    // Collect promises for AST generation
    const astGenerationPromises: Promise<{ relativePath: string; astData: GenericAstNode | null; error?: Error }>[] = [];

    for (const filePath of allFiles.value) {
      const ext = path.extname(filePath).toLowerCase();
      const language = EXTENSION_LANGUAGE_MAP[ext];
      const relativePath = path.relative(rootPath, filePath).replace(/\\/g, '/');

      if (language) {
        astGenerationPromises.push(
          (async () => {
            const readFileResult = await this.fileOps.readFile(filePath);
            if (readFileResult.isErr()) {
              return { relativePath, astData: null, error: readFileResult.error };
            }
            const content = readFileResult.value!;
            const parseResult = this.treeSitterParserService.parse(content, language);
            if (parseResult.isOk()) {
              return { relativePath, astData: parseResult.value! };
            } else {
              return { relativePath, astData: null, error: parseResult.error };
            }
          })()
        );
      } else {
        this.logger.debug(`Skipping unsupported file type for AST generation: ${filePath}`);
        // Optionally push a null result if needed downstream, or just skip
      }
    }

    const astGenerationResults = await Promise.all(astGenerationPromises);
    const validAstData: { relativePath: string; astData: GenericAstNode }[] = [];

    for (const result of astGenerationResults) {
      if (result.astData) {
        validAstData.push({ relativePath: result.relativePath, astData: result.astData });
        this.logger.debug(`Generated generic AST for ${result.relativePath}`);
      } else if (result.error) {
        this.logger.warn(`Failed to generate AST for ${result.relativePath}: ${result.error.message ?? 'Unknown parse error'}`);
      }
    }
    this.logger.debug('Tree-sitter parsing step completed.');
    // --- End Tree-sitter Parsing Step ---

    // --- LLM AST Analysis Step ---
    this.progress.update('Analyzing code structure with LLM...');
    const analysisPromises = validAstData.map(({ relativePath, astData }) =>
      this.astAnalysisService.analyzeAst(astData, relativePath)
        .then(result => ({ relativePath, result })) // Keep track of path
    );

    // Use Promise.allSettled to handle individual analysis failures
    const analysisResults = await Promise.allSettled(analysisPromises);
    const codeInsightsMap: { [filePath: string]: CodeInsights } = {};

    analysisResults.forEach((settledResult, index) => {
      const { relativePath } = validAstData[index]; // Get path from original array

      if (settledResult.status === 'fulfilled') {
        const { result } = settledResult.value;
        if (result.isOk()) {
          codeInsightsMap[relativePath] = result.value;
          this.logger.debug(`Successfully retrieved code insights for ${relativePath}`);
        } else {
          // Log error from AstAnalysisService Result
          this.logger.warn(`Failed to get code insights for file ${relativePath}: ${result.error?.message ?? 'Unknown analysis error'}`);
        }
      } else {
        // Log error from Promise rejection (e.g., unexpected error in analyzeAst)
        this.logger.error(`AST analysis promise rejected for ${relativePath}: ${settledResult.reason}`);
      }
    });
    this.logger.debug('LLM AST analysis step completed.');
    // --- End LLM AST Analysis Step ---


    // ... existing LLM call for overall context (techStack, structure, dependencies) ...
    // ... This part remains largely unchanged, but the final context assembly needs update ...

    // Assemble final context
    const finalContext: ProjectContext = {
      // ... existing techStack, structure, dependencies from the *other* LLM call ...
      techStack: parsedResult.value.techStack ?? { /* defaults */ },
      structure: {
        ...(parsedResult.value.structure ?? { /* defaults */ }),
        rootDir: rootPath,
      },
      dependencies: parsedResult.value.dependencies ?? { /* defaults */ },
      // Add the new fields:
      astData: validAstData.reduce((acc, { relativePath, astData }) => {
        acc[relativePath] = astData;
        return acc;
      }, {} as Record<string, GenericAstNode>), // Populate astData from successful parses
      codeInsights: codeInsightsMap, // Add the map from LLM analysis
    };

    this.progress.succeed('Project context analysis completed successfully');
    this.logger.debug(
      `Final ProjectContext (including astData and codeInsights):\n${JSON.stringify(finalContext, null, 2)}`
    );
    return Result.ok(finalContext);

  } catch (error) {
      // ... existing error handling ...
  }
}

// ... other methods ...
```

**Testing Requirements**:

- Update existing `ProjectAnalyzer` integration tests or add new ones.
- Mock `IAstAnalysisService`.
- Verify `analyzeAst` is called for each file with `astData`.
- Verify calls are concurrent (harder to test directly, but check `Promise.all` usage).
- Verify successful results are merged into `codeInsights`.
- Verify failed results (`Result.err`) are logged as warnings and do not stop the process.

**Related Acceptance Criteria**:

- AC3: Integration logic implemented.
- AC4: Concurrency using `Promise.all`.
- AC9: Error handling for analysis results.
- AC12: TSDoc added for modifications.

**Estimated effort**: 30 minutes

**Required Delegation Components**:

- Implementation components for Junior Coder:
  - Refactor the AST generation loop to collect `astData` and paths.
  - Implement the `Promise.allSettled` logic for concurrent calls and result handling (merging successes, logging failures).
- Testing components for Junior Tester:
  - Update/create integration tests verifying the interaction with the mocked `IAstAnalysisService`, including success and failure cases for individual file analyses.

**Delegation Success Criteria**:

- Junior Coder components must: Correctly implement concurrent calls using `Promise.allSettled`, handle both fulfilled and rejected promises, merge successful insights, and log warnings for failures without stopping execution.
- Junior Tester components must: Tests accurately mock the service, verify concurrent calls (conceptually), check `codeInsights` population, and confirm correct logging behavior on errors.

---

### Subtask 4: DI Registration & Testing

**Status**: Not Started

**Description**: Register the new `AstAnalysisService` for dependency injection and ensure all unit and relevant integration tests pass.

**Files to Modify**:

- `src/core/di/modules/core-module.ts` (or create `src/core/di/modules/analysis-module.ts`)
- Relevant test files (unit tests for `AstAnalysisService`, integration tests for `ProjectAnalyzer`).

**Implementation Details**:

1.  **DI Registration:**

    - Decide if `AstAnalysisService` belongs in `core-module.ts` or a new `analysis-module.ts`. Given its specific nature, `analysis-module.ts` might be cleaner.
    - If creating a new module, add `registerAnalysisModule` to `src/core/di/registrations.ts`.
    - Register `AstAnalysisService` using `container.registerSingleton` or `container.registerFactory`, binding it to the token `'IAstAnalysisService'`.

    ```typescript
    // Example in analysis-module.ts
    import { IServiceContainer } from '../interfaces';
    import { AstAnalysisService } from '../../analysis/ast-analysis.service';
    import { IAstAnalysisService } from '../../analysis/ast-analysis.interfaces';

    export function registerAnalysisModule(container: IServiceContainer): void {
      container.registerFactory<IAstAnalysisService>(
        'IAstAnalysisService',
        (c) => new AstAnalysisService(c.resolve('LLMAgent'), c.resolve('ILogger'))
      );
      // Or container.registerSingleton('IAstAnalysisService', AstAnalysisService); if dependencies are simple
    }
    ```

2.  **Run Tests:** Execute `npm test` and `npm run type-check`. Fix any failures in the new unit tests or existing integration tests.
3.  **Basic Manual Test (AC10):**
    - Create a simple fixture file (e.g., `tests/fixtures/sample.ts`) containing one function, one class, and one import.
    - Temporarily modify `ProjectAnalyzer` or use a test script (like `run-analyzer.js`) to analyze only this file.
    - Add logging within `ProjectAnalyzer` to output the `finalContext.codeInsights` for the sample file.
    - Run the analysis and verify the logged output contains the expected function, class, and import information. Remove temporary logging afterward.

**Testing Requirements**:

- All unit tests for `AstAnalysisService` must pass.
- Relevant integration tests for `ProjectAnalyzer` must pass.
- Manual verification step (AC10) performed.

**Related Acceptance Criteria**:

- AC1: Service registered for DI.
- AC10: Basic functionality verified.

**Estimated effort**: 30 minutes (including manual test)

**Required Delegation Components**:

- Implementation components for Junior Coder:
  - Add DI registration code to the chosen module file.
  - Update `registrations.ts` if a new module was created.
- Testing components for Junior Tester:
  - Execute all tests (`npm test`).
  - Perform the basic manual test (AC10) and document the result.

**Delegation Success Criteria**:

- Junior Coder components must: Service correctly registered with the specified token and dependencies.
- Junior Tester components must: All tests pass. Manual test confirms basic extraction for the sample file.

---

## 5. Technical Considerations

- **Architecture Impact**: Introduces a new service (`AstAnalysisService`) within the analysis layer, adhering to the existing DI and service patterns. Modifies `ProjectAnalyzer`'s responsibilities slightly to orchestrate this new analysis step.
- **Dependencies**: Adds `zod` for runtime validation, a standard and robust library for this purpose.
- **Error Handling**: Leverages the existing `Result` pattern for predictable error flow between `AstAnalysisService` and `ProjectAnalyzer`. Specific errors during analysis (JSON parsing, schema validation) are wrapped in `RooCodeError` or similar. `ProjectAnalyzer` handles errors gracefully by logging and continuing.
- **Concurrency**: `Promise.allSettled` is used in `ProjectAnalyzer` to maximize throughput by analyzing files concurrently while ensuring individual analysis failures don't halt the entire process.
- **Scalability**: The initial approach assumes `astData` fits in context. Future scalability might require implementing chunking/filtering within `AstAnalysisService` if context limits become an issue.

## 6. Testing Approach

- **Unit Tests**: `AstAnalysisService` will have comprehensive unit tests mocking `LLMAgent` and `ILogger`. Tests will cover successful analysis, JSON parsing errors, schema validation errors, and LLM agent errors, ensuring the `Result` type is returned correctly in all cases. `zod` schema definition itself is implicitly tested by its usage in validation.
- **Integration Tests**: Existing `ProjectAnalyzer` integration tests will be updated, or new ones added, to mock `IAstAnalysisService`. These tests will verify that the service is called correctly after `astData` generation, that concurrent calls are orchestrated, and that results (both success and failure) are handled appropriately (merging insights, logging warnings).
- **Manual Verification (AC10)**: A simple manual test using a fixture file will be performed as part of Subtask 4 to provide end-to-end confirmation of the basic extraction functionality.

See [[memory-bank/DeveloperGuide.md#Quality-and-Testing]] for general testing guidelines.

## 7. Implementation Checklist

- [ ] Requirements reviewed (task-description.md)
- [ ] Research report reviewed (task-description.md Section 2)
- [ ] Architecture reviewed (TechnicalArchitecture.md, DeveloperGuide.md)
- [ ] Dependencies checked (`LLMAgent`, `ILogger`, `zod` added)
- [ ] Subtasks defined and sequenced
- [ ] Interfaces defined (`IAstAnalysisService`, `CodeInsights`, etc.)
- [ ] `ProjectContext` updated
- [ ] `AstAnalysisService` implemented (prompt, LLM call, validation)
- [ ] `ProjectAnalyzer` integrated (DI, concurrency, result handling)
- [ ] `zod` dependency added
- [ ] DI registration added
- [ ] Unit tests planned/implemented (`AstAnalysisService`)
- [ ] Integration tests planned/updated (`ProjectAnalyzer`)
- [ ] Manual verification step planned (AC10)
- [ ] Documentation planned (TSDoc comments)
- [ ] Delegation strategy defined for subtasks
