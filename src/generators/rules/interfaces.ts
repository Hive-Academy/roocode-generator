import { ProjectConfig } from '../../../types/shared';
import { Result } from '../../core/result/result';

export interface RulesMetadata {
  mode: string;
  format?: 'markdown' | 'json';
  options?: {
    analysisDepth?: 'basic' | 'detailed';
    includeExamples?: boolean;
  };
}

export interface GeneratedRules {
  mode: string;
  content: string;
  metadata: RulesMetadata;
  contextualInfo: {
    techStack: any;
    projectStructure: any;
    generationDate: string;
  };
}

// Omit baseDir from ProjectConfig since it's optional in our case
export interface RulesConfig extends Omit<ProjectConfig, 'baseDir'> {
  mode: string;
  baseDir: string;
  contextPaths: string[];
  options?: {
    format?: 'markdown' | 'json';
    analysisDepth?: 'basic' | 'detailed';
    includeExamples?: boolean;
  };
}

export interface MultiModeRulesConfig extends Omit<ProjectConfig, 'baseDir'> {
  modes?: string[];
  baseDir: string;
  contextPaths: string[];
  options?: {
    format: 'markdown' | 'json';
    analysisDepth?: 'basic' | 'detailed';
    includeExamples?: boolean;
  };
}

/**
 * Result of validating rules across different modes for consistency.
 */
export interface CrossModeValidationResult {
  /** Whether the rules are valid across all specified modes. */
  isValid: boolean;
  /** Array of conflicts detected between modes. */
  conflicts: Array<{
    /** The pair of modes where the conflict was detected. */
    modes: [string, string];
    /** Description of the conflict for resolution. */
    description: string;
  }>;
}

/**
 * Interface for rules generation, supporting both single-mode and multi-mode generation.
 */
export interface IRulesGenerator {
  /**
   * Generates rules for a single mode according to the provided configuration.
   * @param config Configuration for rules generation
   * @returns Promise resolving to generated rules or an error
   */
  generateRules(config: RulesConfig): Promise<Result<GeneratedRules, Error>>;

  /**
   * Generates rules for multiple modes simultaneously.
   * @param config Configuration including optional array of target modes
   * @returns Promise resolving to a map of mode-specific generated rules or an error
   */
  generateRulesForModes(
    config: MultiModeRulesConfig
  ): Promise<Result<Map<string, GeneratedRules>, Error>>;
}

/**
 * Interface for building prompts specific to rules generation.
 */
export interface IRulesPromptBuilder {
  buildPrompt(instructions: string, context: string, template: string): Result<string, Error>;
  buildSystemPrompt(mode: string): Result<string, Error>;
}

/**
 * Interface for processing the content generated by the LLM for rules.
 */
export interface IRulesContentProcessor {
  processContent(content: string, metadata: RulesMetadata): Result<string, Error>;
  stripMarkdownCodeBlock(content: string): Result<string, Error>;
}

/**
 * @interface IRulesFileManager
 * @description Defines the contract for managing rules files, specifically saving content to a given path.
 */
export interface IRulesFileManager {
  /**
   * Saves the provided content to the specified file path.
   * Ensures the directory exists before writing the file.
   * @async
   * @param {string} filePath - The absolute path where the file should be saved.
   * @param {string} content - The string content to write to the file.
   * @returns {Promise<Result<string, Error>>} A Promise resolving to a Result containing the absolute path to the saved file or an Error.
   */
  saveRules(filePath: string, content: string): Promise<Result<string, Error>>;
}
