import { ProjectConfig } from '../../../types/shared';
import { Result } from '../../core/result/result';

export interface RulesMetadata {
  mode: string;
  format?: 'markdown' | 'json';
  options?: {
    analysisDepth?: 'basic' | 'detailed';
    includeExamples?: boolean;
  };
}

export interface GeneratedRules {
  mode: string;
  content: string;
  metadata: RulesMetadata;
  contextualInfo: {
    techStack: any;
    projectStructure: any;
    generationDate: string;
  };
}

export interface IRulesFileManager {
  saveRules(rules: GeneratedRules): Promise<Result<string, Error>>;
  loadRules(mode: string): Promise<Result<GeneratedRules, Error>>;
}

// Omit baseDir from ProjectConfig since it's optional in our case
export interface RulesConfig extends Omit<ProjectConfig, 'baseDir'> {
  mode: string;
  baseDir: string;
  contextPaths: string[];
  options?: {
    format?: 'markdown' | 'json';
    analysisDepth?: 'basic' | 'detailed';
    includeExamples?: boolean;
  };
}

export interface MultiModeRulesConfig extends Omit<ProjectConfig, 'baseDir'> {
  modes?: string[];
  baseDir: string;
  contextPaths: string[];
  options?: {
    format: 'markdown' | 'json';
    analysisDepth?: 'basic' | 'detailed';
    includeExamples?: boolean;
  };
}

/**
 * Result of validating rules across different modes for consistency.
 */
export interface CrossModeValidationResult {
  /** Whether the rules are valid across all specified modes. */
  isValid: boolean;
  /** Array of conflicts detected between modes. */
  conflicts: Array<{
    /** The pair of modes where the conflict was detected. */
    modes: [string, string];
    /** Description of the conflict for resolution. */
    description: string;
  }>;
}

/**
 * Interface for rules generation, supporting both single-mode and multi-mode generation.
 */
export interface IRulesGenerator {
  /**
   * Generates rules for a single mode according to the provided configuration.
   * @param config Configuration for rules generation
   * @returns Promise resolving to generated rules or an error
   */
  generateRules(config: RulesConfig): Promise<Result<GeneratedRules, Error>>;

  /**
   * Generates rules for multiple modes simultaneously.
   * @param config Configuration including optional array of target modes
   * @returns Promise resolving to a map of mode-specific generated rules or an error
   */
  generateRulesForModes(
    config: MultiModeRulesConfig
  ): Promise<Result<Map<string, GeneratedRules>, Error>>;
}

/**
 * Interface for building prompts specific to rules generation.
 */
export interface IRulesPromptBuilder {
  buildPrompt(instructions: string, context: string, template: string): Result<string, Error>;
  buildSystemPrompt(mode: string): Result<string, Error>;
}

/**
 * Interface for processing the content generated by the LLM for rules.
 */
export interface IRulesContentProcessor {
  processContent(content: string, metadata: RulesMetadata): Result<string, Error>;
  stripMarkdownCodeBlock(content: string): Result<string, Error>;
}

/**
 * @interface IRulesFileManager
 * @description Defines the contract for managing rules files, including saving, loading,
 * versioning, and backups within the standard `.roo` directory structure.
 */
export interface IRulesFileManager {
  /**
   * Saves the generated rules to the appropriate file, handling versioning.
   * Creates a new version entry in the history file.
   * @async
   * @param {GeneratedRules} rules - The generated rules object to save.
   * @returns {Promise<Result<string, Error>>} A Promise resolving to a Result containing the absolute path to the saved file or an Error.
   */
  saveRules(rules: GeneratedRules): Promise<Result<string, Error>>;

  /**
   * Loads rules for a specific mode, optionally specifying a version.
   * If no version is specified, loads the latest version based on the history file.
   * @async
   * @param {string} mode - The mode for which to load rules (e.g., 'architect').
   * @param {string} [version] - Optional version identifier (e.g., '20230101120000') to load.
   * @returns {Promise<Result<GeneratedRules, Error>>} A Promise resolving to a Result containing the loaded GeneratedRules object or an Error.
   */
  loadRules(mode: string, version?: string): Promise<Result<GeneratedRules, Error>>;

  /**
   * Creates a timestamped backup of the latest rules file for a given mode.
   * @async
   * @param {string} mode - The mode for which to back up rules.
   * @returns {Promise<Result<void, Error>>} A Promise resolving to a Result indicating success (void) or an Error.
   */
  backupRules(mode: string): Promise<Result<void, Error>>;

  /**
   * Validates the structure and content of a specific rules file.
   * Implementations should at least check for valid JSON. More complex validation (e.g., schema) can be added.
   * @async
   * @param {string} path - The absolute path to the rules file to validate.
   * @returns {Promise<Result<void, Error>>} A Promise resolving to a Result indicating success (void) or an Error if validation fails.
   */
  validateRulesFile(path: string): Promise<Result<void, Error>>;

  /**
   * Lists available versions for a specific mode based on the version history file.
   * @async
   * @param {string} mode - The mode for which to list versions.
   * @returns {Promise<Result<RuleVersion[], Error>>} A Promise resolving to a Result containing an array of RuleVersion objects or an Error.
   */
  listRuleVersions(mode: string): Promise<Result<RuleVersion[], Error>>;
}

/**
 * @interface RuleVersion
 * @description Represents metadata for a specific version of a rules file, as stored in the version history.
 */
export interface RuleVersion {
  /** @property {string} version - The unique version identifier (e.g., '20230101120000'). */
  version: string;
  /** @property {string} timestamp - The ISO 8601 timestamp when this version was created. */
  timestamp: string;
  /** @property {string} mode - The mode associated with this rule version (e.g., 'architect'). */
  mode: string;
  /** @property {string} path - The relative path from the base directory (`.roo`) to the rules file for this version. */
  path: string;
  /** @property {RulesMetadata} metadata - The metadata associated with the rules content at the time this version was saved. */
  metadata: RulesMetadata;
}

/**
 * @interface RulesFileStructure
 * @description Defines the standard directory and file names used for managing rules files.
 */
export interface RulesFileStructure {
  /** @property {string} baseDir - The base directory relative to the project root for all RooCode Generator files (e.g., '.roo'). */
  baseDir: string;
  /** @property {string} modesDir - The subdirectory within `baseDir` containing mode-specific rules directories (e.g., 'rules'). */
  modesDir: string;
  /** @property {string} backupDir - The subdirectory within `baseDir` for rule backups (e.g., 'rules-backup'). */
  backupDir: string;
  /** @property {string} versionFile - The name of the JSON file within `baseDir` storing version history (e.g., 'rules-versions.json'). */
  versionFile: string;
}
